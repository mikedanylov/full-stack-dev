/*jslint node: true */
require('shelljs/global');
'use strict';

var gulp = require('gulp');
var argv = require('yargs').argv;
var autoprefixer = require('gulp-autoprefixer');
var babelify = require('babelify');
var beautify = require('gulp-beautify');
var browserify = require('browserify');
var browserSync = require('browser-sync');
var concat = require('gulp-concat');
var del = require('del');
var gulpif = require('gulp-if');
var jshint = require('gulp-jshint');
var livereload = require('gulp-livereload');
var minifycss = require('gulp-minify-css');
var notify = require('gulp-notify');
var path = require('path');
var plumber = require('gulp-plumber');
var reload = browserSync.reload;
var rename = require('gulp-rename');
var sass = require('gulp-ruby-sass');
var source = require('vinyl-source-stream');
var sourcemaps = require('gulp-sourcemaps');
var streamify = require('gulp-streamify');
var uglify = require('gulp-uglify');
var watch = require('gulp-watch');

var REPO = 'frunt';
var PROD = process.env.NODE_ENV !== 'dev';
var PAGES = '_gh_pages';

var dist = './dist/',
    docs = './docs/';

var paths = {
    src: {
        sass: './sass/',
        js: './js/',
    },
    dist: {
        css: dist + 'css/',
        js: dist + 'js/'
    },
    docs: {
        src: {
            sass: docs + 'src/sass/',
            js: docs + 'src/js/',
        },
        dist: {
            css: docs + 'assets/css/',
            js: docs + 'assets/js/',
        }
    }
};

// Sass // --------------------------------------------------

gulp.task('styles', function () {
    return sass(paths.src.sass + 'frunt.scss', {
            style: 'nested',
            loadPath: []
        })
        .pipe(plumber({ errorHandler: function (err) { console.log(err); } }))
        .pipe(autoprefixer('last 2 version'))
        .pipe(beautify())
        .pipe(gulp.dest(paths.dist.css))
        .pipe(gulpif(argv.livereload, livereload(), reload({stream: true})))
        .pipe(notify({message: 'Styles Complete'}));
});

// Scripts // --------------------------------------------------

gulp.task('lint', function () {
    gulp.src([paths.src.js + 'frunt.js', paths.src.js + 'modules/*.js', './gulpfile.js'])
        .pipe(jshint())
        .pipe(jshint.reporter('default'));
});

gulp.task('browserify', function () {
    return browserify({ entries: [paths.src.js + 'frunt.js']})
        .transform(babelify, { stage: 0 })
        .bundle()
        .on('error', function(e){
            console.log(e.message);
            this.emit('end');
        })
        .pipe(source('frunt.js'))
        .pipe(gulpif(argv.beautify, streamify(beautify()), streamify(uglify())))
        .pipe(gulpif(argv.livereload, livereload(), reload({stream: true})))
        .pipe(gulp.dest(paths.dist.js))
        .pipe(notify({message: 'Browserify Complete'}));
});

// HTML // --------------------------------------------------

gulp.task('html', function () {
    gulp.src(docs + '/**/*.html')
        .pipe(gulpif(argv.livereload, livereload(), reload({stream: true})));
});

// Server // --------------------------------------------------

gulp.task('browser-sync', function () {
    browserSync({
        notify: false,
        ghostMode: {
            clicks: true,
            forms: true,
            scroll: true
        },
        server: {
            baseDir: docs
        }
    });
});

// Compress // --------------------------------------------------

gulp.task('compress:css', ['styles', 'styles:docs'], function () {
    return gulp.src(paths.dist.css + 'frunt.css')
        .pipe(sourcemaps.init())
        .pipe(minifycss({processImport: false}))
        .pipe(sourcemaps.write('./'))
        .pipe(rename({
             suffix: '.min'
         }))
        .pipe(gulp.dest(paths.dist.css));
});

gulp.task('compress:js', ['browserify', 'browserify:docs'], function () {
    return gulp.src(paths.dist.js + 'frunt.js')
        .pipe(sourcemaps.init())
        .pipe(uglify())
        .pipe(sourcemaps.write('./'))
        .pipe(rename({
             suffix: '.min'
         }))
        .pipe(gulp.dest(paths.dist.js));
});

// Docs // --------------------------------------------------

gulp.task('styles:docs', ['styles'], function () {
    return sass(paths.docs.src.sass + 'style.scss', {
            style: 'nested',
            loadPath: []
        })
        .pipe(plumber({ errorHandler: function (err) { console.log(err); } }))
        .pipe(autoprefixer('last 2 version'))
        .pipe(minifycss({processImport: false}))
        .pipe(gulp.dest(paths.docs.dist.css))
        .pipe(gulpif(argv.livereload, livereload(), reload({stream: true})))
        .pipe(notify({message: 'Styles Complete'}));
});

gulp.task('browserify:docs', ['browserify'], function () {
    return browserify({ entries: [paths.docs.src.js + 'app.js']})
        .transform(babelify, { stage: 0 })
        .bundle()
        .on('error', function(e){
            console.log(e.message);
            this.emit('end');
        })
        .pipe(source('bundle.js'))
        .pipe(gulpif(argv.beautify, streamify(beautify()), streamify(uglify())))
        .pipe(gulpif(argv.livereload, livereload(), reload({stream: true})))
        .pipe(gulp.dest(paths.docs.dist.js))
        .pipe(notify({message: 'Browserify Complete'}));
});

// Release // --------------------------------------------------

gulp.task('clean', function(done) {
  del(PAGES, done);
});

gulp.task('deploy', ['default'], function() {
    // build jekyll
    exec('jekyll build');

    // Create a tempory directory and
    // checkout the existing gh-pages branch.
    rm('-rf', '_tmp');
    mkdir('_tmp');
    cd('_tmp');
    exec('git init');
    exec('git remote add origin git@github.com:picdorsey/' + REPO + '.git');
    exec('git pull origin gh-pages');

    // Delete all the existing files and add
    // the new ones from the build directory.
    rm('-rf', './*');
    cp('-rf', path.join('..', PAGES, '/'), './');
    exec('git add -A');

    // Commit and push the changes to
    // the gh-pages branch.
    exec('git commit -m "Deploy site."');
    exec('git branch -m gh-pages');
    exec('git push origin gh-pages');

    // Clean up.
    cd('..');
    rm('-rf', '_tmp');
    rm('-rf', PAGES);
});

// Task // --------------------------------------------------

gulp.task('watch', function () {
    watch([paths.src.js + '**/*.js', paths.docs.src.js + '**/*.js'], function () {
        gulp.start(['lint', 'browserify', 'browserify:docs', 'compress:js']);
    });

    watch([paths.src.sass + '**/*.scss', paths.docs.src.sass + '**/*.scss'], function () {
        gulp.start('styles', 'styles:docs', 'compress:css');
    });

    watch(docs + '/**/*.html', function () {
        gulp.start('html');
    });
});

gulp.task('dev', function () {
    gulp.start('watch');

    if (argv.livereload) {
        livereload.listen();
    } else {
        gulp.start('browser-sync');
    }
});

gulp.task('test', function () {
    gulp.start('lint');
});

gulp.task('default', function () {
    gulp.start('styles', 'styles:docs', 'browserify', 'browserify:docs', 'compress:css', 'compress:js');
});
